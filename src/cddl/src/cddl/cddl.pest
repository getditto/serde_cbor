/**
 * Based on the ABNF appendix B from RFC-8610
 *   rf. https://tools.ietf.org/html/rfc8610
 * We try to keep the rule names as close as possible as the ABNF rules.
 */
WHITESPACE = _{ " " | "\t" | "\r" | "\n" | "\r\n" }
COMMENT = _{ ";" ~ ( !"\n" ~ ANY )* ~ "\n" }

cddl = _{ SOI ~ rule* ~ EOI }
rule = _{ rule_typename | rule_groupname }

rule_typename = { id_genericparm ~ assignt ~ type_ }
rule_groupname = { id_genericparm ~ assigng ~ grpent }

id_genericparm = ${ id ~ genericparm? }
id_genericarg = ${ id ~ genericarg? }

assignt = { "=" | "/=" }
assigng = { "=" | "//=" }

genericparm = !{ "<" ~ id ~ ("," ~ id)* ~ ">" }
genericarg = !{ "<" ~ type1 ~ ("," ~ type1)* ~ ">" }

type_ = !{ type1 ~ ("/" ~ type1)* }  // `type` is a Rust keyword.
type1 = { type2 ~ ((rangeop | ctlop) ~ type2)? }

type2 = {
      value
    | type2_typeref
    | type2_paren
    | type2_map
    | type2_array
    | type2_unwrap
    | type2_choice
    | type2_choice2
    | type2_tag
    | type2_major
    | type2_any
}

type2_typeref = { id_genericarg }
type2_paren = { "(" ~ type_ ~ ")" }
type2_map = { "{" ~ group ~ "}" }
type2_array = { "[" ~ group ~ "]" }
type2_unwrap = { "~" ~ id_genericarg }
type2_choice = { "&" ~ "(" ~ group ~ ")" }
type2_choice2 = { "&" ~ id_genericarg }
type2_tag = ${  "#6" ~ ("." ~ uint)? ~ type2_tagged_type }  // tag
type2_tagged_type = !{ "(" ~ type_ ~ ")" }
type2_major = ${ "#" ~ type2_major_digit ~ ( "." ~ uint )? }  // major/ai
type2_major_digit = { ASCII_DIGIT }
type2_any = { "#" }  // any

rangeop = ${ "..." | ".." }

ctlop = ${ "." ~ id }

group = { grpchoice ~ ("//" ~ grpchoice)* }
grpchoice = _{ (grpent ~ optcom)* }

grpent = _{ grpent_memberkey | grpent_genericarg | grpent_group }
grpent_memberkey = !{ occur? ~ memberkey? ~ type_ }
grpent_genericarg = !{ occur? ~ id_genericarg }
grpent_group = !{ occur? ~ "(" ~ group ~ ")" }

memberkey = {
    (type1 ~ "^"? ~ "=>")
    | (bareword ~ ":")
    | (value ~ ":")
}

bareword = _{ id }

optcom = _{ ","? }

occur = @{
    (uint? ~ "*" ~ uint?)
    | "+"
    | "?"
}

uint = @{
    (ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*)
    | ("0x" ~ ASCII_HEX_DIGIT+)
    | ("0b" ~ ASCII_BIN_DIGIT+)
    | ("0")
}

value = ${
    number
    | text
    | bytes
}

int = @{ "-"? ~ uint }

// This is a float if it has fraction or exponent; int otherwise
number = ${
   hexfloat
   | (int ~ ("." ~ fraction)? ~ ("e" ~ exponent)?)
}
hexfloat = ${
   "-"? ~ "0x" ~ ASCII_HEX_DIGIT+ ~ ("." ~ ASCII_HEX_DIGIT+)? ~ "p" ~ exponent
}
fraction = @{ ASCII_DIGIT+ }
exponent = @{ ("+" | "-") ~ ASCII_DIGIT+ }

text = ${ "\x22" ~ SCHAR* ~ "\x22" }
SCHAR = @{
    ('\x20'..'\x21')
    | ('\x23'..'\x5B')
    | ('\x5D'..'\x7E')
    | ('\x80'..'\u{10FFFD}')
    | SESC
}
SESC = @{ "\\" ~ ('\x20'..'\x7E' | '\x80'..'\u{10FFFD}') }

bytes = @{ bsqual? ~ "\x27" ~ BCHAR* ~ "\x27" }
BCHAR = @{ ('\x20'..'\x26') | ('\x28'..'\x5B') | ('\x5D'..'\u{10FFFD}') | SESC | CRLF }
bsqual = @{ "h" | "b64" }

id = @{ EALPHA ~ (("-" | ".")* ~ (EALPHA | DIGIT))* }
ALPHA = @{ '\x41'..'\x5A' | '\x61'..'\x7A' }
EALPHA = @{ ALPHA | "@" | "_" | "$" }
DIGIT = @{ '\x30'..'\x39' }
CRLF = @{ "\r" | "\r\n" }
